name: Release

on:
  push:
    tags:
      - "v*"

permissions:
  contents: write

env:
  CARGO_TERM_COLOR: always

jobs:
  prepare:
    runs-on: ubuntu-latest
    outputs:
      tag: ${{ steps.meta.outputs.tag }}
      version_core: ${{ steps.meta.outputs.version_core }}
      prerelease: ${{ steps.meta.outputs.prerelease }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Parse tag metadata
        id: meta
        shell: bash
        run: |
          set -euo pipefail

          TAG="${GITHUB_REF_NAME}"
          CORE=""
          PRERELEASE="false"

          if [[ "$TAG" =~ ^v([0-9]+\.[0-9]+\.[0-9]+)$ ]]; then
            CORE="${BASH_REMATCH[1]}"
            PRERELEASE="false"
          elif [[ "$TAG" =~ ^v([0-9]+\.[0-9]+\.[0-9]+)-beta\.([0-9]+)$ ]]; then
            CORE="${BASH_REMATCH[1]}"
            PRERELEASE="true"
          else
            echo "::error::Tag must match vX.Y.Z or vX.Y.Z-beta.N"
            exit 1
          fi

          WORKSPACE_VERSION="$(awk '
            /^\[workspace\.package\]/ { in_section=1; next }
            /^\[/ && in_section { in_section=0 }
            in_section && /^version = / {
              gsub(/"/, "", $3)
              print $3
              exit
            }
          ' Cargo.toml)"

          if [[ "$WORKSPACE_VERSION" != "$CORE" ]]; then
            echo "::error::Tag core version ($CORE) must match workspace version ($WORKSPACE_VERSION)."
            exit 1
          fi

          echo "tag=$TAG" >> "$GITHUB_OUTPUT"
          echo "version_core=$CORE" >> "$GITHUB_OUTPUT"
          echo "prerelease=$PRERELEASE" >> "$GITHUB_OUTPUT"

  build-macos:
    needs: prepare
    strategy:
      fail-fast: false
      matrix:
        include:
          - runner: macos-14
            arch: arm64
            target: aarch64-apple-darwin
          - runner: macos-14
            arch: x64
            target: x86_64-apple-darwin
    runs-on: ${{ matrix.runner }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      - name: Rust cache
        uses: Swatinem/rust-cache@v2

      - name: Import Apple signing certificate
        shell: bash
        env:
          APPLE_SIGNING_CERTIFICATE_P12_BASE64: ${{ secrets.APPLE_SIGNING_CERTIFICATE_P12_BASE64 }}
          APPLE_SIGNING_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_SIGNING_CERTIFICATE_PASSWORD }}
        run: |
          set -euo pipefail

          test -n "$APPLE_SIGNING_CERTIFICATE_P12_BASE64"
          test -n "$APPLE_SIGNING_CERTIFICATE_PASSWORD"

          KEYCHAIN_PASSWORD="$(openssl rand -hex 16)"
          KEYCHAIN_PATH="$RUNNER_TEMP/butterpaper-signing.keychain-db"
          CERT_PATH="$RUNNER_TEMP/butterpaper-signing.p12"

          CERT_PATH="$CERT_PATH" python3 - <<'PY'
          import base64
          import os
          from pathlib import Path

          data = os.environ["APPLE_SIGNING_CERTIFICATE_P12_BASE64"]
          Path(os.environ["CERT_PATH"]).write_bytes(base64.b64decode(data))
          PY

          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security list-keychains -d user -s "$KEYCHAIN_PATH"
          security import "$CERT_PATH" \
            -k "$KEYCHAIN_PATH" \
            -P "$APPLE_SIGNING_CERTIFICATE_PASSWORD" \
            -T /usr/bin/codesign \
            -T /usr/bin/security
          security set-key-partition-list -S apple-tool:,apple: -s -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

      - name: Install cargo-bundle
        shell: bash
        run: cargo install cargo-bundle --locked

      - name: Build and package macOS bundles
        shell: bash
        env:
          VERSION_CORE: ${{ needs.prepare.outputs.version_core }}
          PRERELEASE: ${{ needs.prepare.outputs.prerelease }}
          APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_SIGNING_IDENTITY }}
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
          APPLE_APP_SPECIFIC_PASSWORD: ${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }}
          APPLE_NOTARYTOOL_KEY_ID: ${{ secrets.APPLE_NOTARYTOOL_KEY_ID }}
          APPLE_NOTARYTOOL_ISSUER_ID: ${{ secrets.APPLE_NOTARYTOOL_ISSUER_ID }}
          APPLE_NOTARYTOOL_KEY_P8_BASE64: ${{ secrets.APPLE_NOTARYTOOL_KEY_P8_BASE64 }}
        run: |
          set -euo pipefail

          test -n "$APPLE_SIGNING_IDENTITY"

          cargo bundle --release --format osx --package butterpaper --target "${{ matrix.target }}"

          APP_PATH="target/${{ matrix.target }}/release/bundle/osx/ButterPaper.app"
          if [[ ! -d "$APP_PATH" ]]; then
            echo "::error::Expected app bundle not found at $APP_PATH"
            exit 1
          fi

          bash scripts/apply_macos_tahoe_bundle_icons.sh "$APP_PATH"

          codesign --force --deep --options runtime --timestamp --sign "$APPLE_SIGNING_IDENTITY" "$APP_PATH"
          codesign --verify --deep --strict --verbose=2 "$APP_PATH"

          NOTARY_MODE="none"
          NOTARY_KEY_PATH=""
          if [[ -n "${APPLE_ID:-}" && -n "${APPLE_TEAM_ID:-}" && -n "${APPLE_APP_SPECIFIC_PASSWORD:-}" ]]; then
            NOTARY_MODE="apple_id"
          elif [[ -n "${APPLE_NOTARYTOOL_KEY_ID:-}" && -n "${APPLE_NOTARYTOOL_ISSUER_ID:-}" && -n "${APPLE_NOTARYTOOL_KEY_P8_BASE64:-}" ]]; then
            NOTARY_MODE="api_key"
            NOTARY_KEY_PATH="$RUNNER_TEMP/apple-notary-api-key.p8"
            NOTARY_KEY_PATH="$NOTARY_KEY_PATH" python3 -c 'import base64,os; from pathlib import Path; Path(os.environ["NOTARY_KEY_PATH"]).write_bytes(base64.b64decode(os.environ["APPLE_NOTARYTOOL_KEY_P8_BASE64"]))'
          fi

          maybe_notarize_and_staple() {
            local app_path="$1"
            if [[ "$NOTARY_MODE" == "none" ]]; then
              return 0
            fi

            local tmp_zip="$RUNNER_TEMP/notary-upload.zip"
            rm -f "$tmp_zip"
            ditto -c -k --sequesterRsrc --keepParent "$app_path" "$tmp_zip"

            if [[ "$NOTARY_MODE" == "api_key" ]]; then
              xcrun notarytool submit "$tmp_zip" \
                --key "$NOTARY_KEY_PATH" \
                --key-id "$APPLE_NOTARYTOOL_KEY_ID" \
                --issuer "$APPLE_NOTARYTOOL_ISSUER_ID" \
                --wait
            else
              xcrun notarytool submit "$tmp_zip" \
                --apple-id "$APPLE_ID" \
                --team-id "$APPLE_TEAM_ID" \
                --password "$APPLE_APP_SPECIFIC_PASSWORD" \
                --wait
            fi

            xcrun stapler staple -v "$app_path"
          }

          mkdir -p dist

          package_stable() {
            local output="dist/ButterPaper-v${VERSION_CORE}-macos-${{ matrix.arch }}.zip"
            maybe_notarize_and_staple "$APP_PATH"
            ditto -c -k --sequesterRsrc --keepParent "$APP_PATH" "$output"
          }

          package_beta() {
            local tmp_dir
            tmp_dir="$(mktemp -d)"
            cp -R "$APP_PATH" "$tmp_dir/ButterPaper Beta.app"
            local plist="$tmp_dir/ButterPaper Beta.app/Contents/Info.plist"
            /usr/libexec/PlistBuddy -c "Set :CFBundleDisplayName ButterPaper Beta" "$plist" || true
            /usr/libexec/PlistBuddy -c "Set :CFBundleName ButterPaper Beta" "$plist" || true
            /usr/libexec/PlistBuddy -c "Set :CFBundleIdentifier com.apotenza92.butterpaper.beta" "$plist" || true
            bash scripts/apply_macos_tahoe_bundle_icons.sh "$tmp_dir/ButterPaper Beta.app" beta
            codesign --force --deep --options runtime --timestamp --sign "$APPLE_SIGNING_IDENTITY" "$tmp_dir/ButterPaper Beta.app"
            codesign --verify --deep --strict --verbose=2 "$tmp_dir/ButterPaper Beta.app"
            maybe_notarize_and_staple "$tmp_dir/ButterPaper Beta.app"
            local output="dist/ButterPaper-Beta-v${VERSION_CORE}-macos-${{ matrix.arch }}.zip"
            ditto -c -k --sequesterRsrc --keepParent "$tmp_dir/ButterPaper Beta.app" "$output"
            rm -rf "$tmp_dir"
          }

          if [[ "$PRERELEASE" == "true" ]]; then
            package_beta
          else
            package_stable
            package_beta
          fi

      - name: Upload macOS artifacts
        uses: actions/upload-artifact@v4
        with:
          name: release-macos-${{ matrix.arch }}
          path: dist/*
          if-no-files-found: error

  build-windows:
    needs: prepare
    strategy:
      fail-fast: false
      matrix:
        include:
          - arch: x64
            target: x86_64-pc-windows-msvc
          - arch: arm64
            target: aarch64-pc-windows-msvc
    runs-on: windows-2022
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      - name: Rust cache
        uses: Swatinem/rust-cache@v2

      - name: Install NSIS
        shell: pwsh
        run: |
          if (-not (Get-Command makensis -ErrorAction SilentlyContinue)) {
            choco install nsis -y --no-progress
          }

      - name: Build and package Windows installers
        shell: pwsh
        env:
          VERSION_CORE: ${{ needs.prepare.outputs.version_core }}
          PRERELEASE: ${{ needs.prepare.outputs.prerelease }}
        run: |
          $ErrorActionPreference = "Stop"

          $stableBinary = $null
          $betaBinary = $null

          if ($env:PRERELEASE -ne "true") {
            cargo build --release --package butterpaper --target "${{ matrix.target }}"
            $binary = Join-Path $PWD "target\${{ matrix.target }}\release\butterpaper.exe"
            if (!(Test-Path $binary)) {
              throw "Expected stable binary not found: $binary"
            }
            $stableBinary = Join-Path $env:RUNNER_TEMP "butterpaper-stable-${{ matrix.arch }}.exe"
            Copy-Item -Force $binary $stableBinary
          }

          cargo build --release --package butterpaper --target "${{ matrix.target }}" --features beta
          $binary = Join-Path $PWD "target\${{ matrix.target }}\release\butterpaper.exe"
          if (!(Test-Path $binary)) {
            throw "Expected beta binary not found: $binary"
          }
          $betaBinary = Join-Path $env:RUNNER_TEMP "butterpaper-beta-${{ matrix.arch }}.exe"
          Copy-Item -Force $binary $betaBinary

          New-Item -ItemType Directory -Force -Path dist | Out-Null
          $nsisScript = Join-Path $PWD "scripts\release\windows_installer.nsi"

          function Build-Installer([string]$prefix, [string]$appName, [string]$installSubdir, [string]$sourceExe) {
            $output = Join-Path $PWD ("dist\{0}-v{1}-windows-${{ matrix.arch }}-setup.exe" -f $prefix, $env:VERSION_CORE)
            $args = @(
              "/DOUTPUT_FILE=$output",
              "/DSOURCE_EXE=$sourceExe",
              "/DAPP_NAME=$appName",
              "/DINSTALL_SUBDIR=$installSubdir",
              $nsisScript
            )
            & makensis @args
          }

          if ($env:PRERELEASE -eq "true") {
            Build-Installer "ButterPaper-Beta" "ButterPaper Beta" "ButterPaper-Beta" $betaBinary
          } else {
            Build-Installer "ButterPaper" "ButterPaper" "ButterPaper" $stableBinary
            Build-Installer "ButterPaper-Beta" "ButterPaper Beta" "ButterPaper-Beta" $betaBinary
          }

      - name: Upload Windows artifacts
        uses: actions/upload-artifact@v4
        with:
          name: release-windows-${{ matrix.arch }}
          path: dist/*
          if-no-files-found: error

  build-linux:
    needs: prepare
    strategy:
      fail-fast: false
      matrix:
        include:
          - runner: ubuntu-24.04
            arch: x64
            target: x86_64-unknown-linux-gnu
            deb_arch: amd64
            rpm_arch: x86_64
            appimage_arch: x86_64
          - runner: ubuntu-24.04-arm
            arch: arm64
            target: aarch64-unknown-linux-gnu
            deb_arch: arm64
            rpm_arch: aarch64
            appimage_arch: aarch64
    runs-on: ${{ matrix.runner }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      - name: Rust cache
        uses: Swatinem/rust-cache@v2

      - name: Install packaging dependencies
        shell: bash
        run: |
          set -euo pipefail
          sudo apt-get update
          sudo apt-get install -y \
            build-essential \
            pkg-config \
            rpm \
            ruby \
            ruby-dev \
            libpipewire-0.3-dev \
            libspa-0.2-dev \
            libegl1-mesa-dev \
            libgl1-mesa-dev \
            libgbm-dev \
            libxkbcommon-dev \
            libxkbcommon-x11-dev \
            libwayland-dev \
            libx11-dev \
            libxi-dev \
            libxcursor-dev \
            libxrandr-dev \
            libxinerama-dev \
            libdbus-1-dev \
            libudev-dev \
            libasound2-dev
          sudo gem install --no-document fpm

      - name: Build and package Linux artifacts
        shell: bash
        env:
          VERSION_CORE: ${{ needs.prepare.outputs.version_core }}
          PRERELEASE: ${{ needs.prepare.outputs.prerelease }}
          APPIMAGE_ARCH: ${{ matrix.appimage_arch }}
          TARGET_TRIPLE: ${{ matrix.target }}
          DEB_ARCH: ${{ matrix.deb_arch }}
          RPM_ARCH: ${{ matrix.rpm_arch }}
          OUT_ARCH: ${{ matrix.arch }}
        run: |
          set -euo pipefail

          cargo build --release --package butterpaper --target "$TARGET_TRIPLE"

          BIN_PATH="target/$TARGET_TRIPLE/release/butterpaper"
          if [[ ! -x "$BIN_PATH" ]]; then
            echo "::error::Expected binary not found at $BIN_PATH"
            exit 1
          fi

          mkdir -p dist

          curl -fsSL -o appimagetool \
            "https://github.com/AppImage/appimagetool/releases/download/1.9.1/appimagetool-${APPIMAGE_ARCH}.AppImage"
          chmod +x appimagetool
          export ARCH="$APPIMAGE_ARCH"
          export APPIMAGE_EXTRACT_AND_RUN=1

          build_variant() {
            local channel="$1"        # stable|beta
            local prefix="$2"         # ButterPaper|ButterPaper-Beta
            local desktop_name="$3"   # ButterPaper|ButterPaper Beta

            local icon_src="crates/gpui-app/assets/app-icons/butterpaper-icon-256.png"
            if [[ "$channel" == "beta" ]]; then
              icon_src="crates/gpui-app/assets/app-icons/butterpaper-icon-beta-256.png"
            fi

            local workdir
            workdir="$(mktemp -d)"

            local appdir="$workdir/AppDir"
            mkdir -p "$appdir/usr/bin" "$appdir/usr/share/applications" "$appdir/usr/share/icons/hicolor/256x256/apps"
            cp "$BIN_PATH" "$appdir/usr/bin/ButterPaper"
            chmod +x "$appdir/usr/bin/ButterPaper"

            # appimagetool falls back to scanning *.so.* for architecture; provide one deterministically.
            mkdir -p "$appdir/usr/lib"
            ln -sf ../bin/ButterPaper "$appdir/usr/lib/libbutterpaper.so.0"

            cp "$icon_src" "$appdir/usr/share/icons/hicolor/256x256/apps/butterpaper.png"

            DESKTOP_NAME="$desktop_name" APPDIR="$appdir" python3 - <<'PY'
          import os
          from pathlib import Path

          appdir = os.environ["APPDIR"]
          name = os.environ["DESKTOP_NAME"]

          Path(f"{appdir}/butterpaper.desktop").write_text(
              "[Desktop Entry]\n"
              f"Name={name}\n"
              "Comment=Rust-native desktop PDF app\n"
              "Exec=ButterPaper\n"
              "Icon=butterpaper\n"
              "Type=Application\n"
              "Categories=Office;Viewer;\n"
              "Terminal=false\n",
              encoding="utf-8",
          )

          Path(f"{appdir}/AppRun").write_text(
              "#!/bin/sh\n"
              "HERE=\\\"$(dirname \\\"$(readlink -f \\\"$0\\\")\\\")\\\"\n"
              "exec \\\"$HERE/usr/bin/ButterPaper\\\" \\\"$@\\\"\\n",
              encoding="utf-8",
          )
          PY

            cp "$appdir/butterpaper.desktop" "$appdir/usr/share/applications/butterpaper.desktop"
            chmod +x "$appdir/AppRun"
            ln -s usr/share/icons/hicolor/256x256/apps/butterpaper.png "$appdir/butterpaper.png"

            local appimage_tmp="$workdir/ButterPaper-${OUT_ARCH}.AppImage"
            ./appimagetool --no-appstream "$appdir" "$appimage_tmp"
            cp "$appimage_tmp" "dist/${prefix}-v${VERSION_CORE}-linux-${OUT_ARCH}.AppImage"

            local pkgroot="$workdir/PkgRoot"
            mkdir -p "$pkgroot/usr/bin" "$pkgroot/usr/share/applications" "$pkgroot/usr/share/icons/hicolor/256x256/apps"
            cp "$BIN_PATH" "$pkgroot/usr/bin/butterpaper"
            chmod +x "$pkgroot/usr/bin/butterpaper"
            cp "$appdir/butterpaper.desktop" "$pkgroot/usr/share/applications/butterpaper.desktop"
            cp "$icon_src" "$pkgroot/usr/share/icons/hicolor/256x256/apps/butterpaper.png"

            pushd "$workdir" >/dev/null
            fpm -s dir -t deb \
              -n butterpaper \
              -v "$VERSION_CORE" \
              -a "$DEB_ARCH" \
              --maintainer "apotenza92" \
              --description "Rust-native desktop PDF app" \
              --url "https://github.com/apotenza92/ButterPaper" \
              -C "$pkgroot" \
              .

            fpm -s dir -t rpm \
              -n butterpaper \
              -v "$VERSION_CORE" \
              -a "$RPM_ARCH" \
              --maintainer "apotenza92" \
              --description "Rust-native desktop PDF app" \
              --url "https://github.com/apotenza92/ButterPaper" \
              -C "$pkgroot" \
              .
            popd >/dev/null

            local deb_file
            deb_file="$(ls -1 "$workdir"/butterpaper_"${VERSION_CORE}"_*.deb | head -n1)"
            local rpm_file
            rpm_file="$(ls -1 "$workdir"/butterpaper-"${VERSION_CORE}"-*.rpm | head -n1)"

            cp "$deb_file" "dist/${prefix}-v${VERSION_CORE}-linux-${OUT_ARCH}.deb"
            cp "$rpm_file" "dist/${prefix}-v${VERSION_CORE}-linux-${OUT_ARCH}.rpm"

            rm -rf "$workdir"
          }

          if [[ "$PRERELEASE" == "true" ]]; then
            build_variant beta "ButterPaper-Beta" "ButterPaper Beta"
          else
            build_variant stable "ButterPaper" "ButterPaper"
            build_variant beta "ButterPaper-Beta" "ButterPaper Beta"
          fi

      - name: Upload Linux artifacts
        uses: actions/upload-artifact@v4
        with:
          name: release-linux-${{ matrix.arch }}
          path: dist/*
          if-no-files-found: error

  publish-release:
    needs:
      - prepare
      - build-macos
      - build-windows
      - build-linux
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: release-*
          merge-multiple: true
          path: dist

      - name: Publish GitHub release
        env:
          GH_TOKEN: ${{ github.token }}
          GH_REPO: ${{ github.repository }}
          TAG: ${{ needs.prepare.outputs.tag }}
          PRERELEASE: ${{ needs.prepare.outputs.prerelease }}
        shell: bash
        run: |
          set -euo pipefail

          ls -lah dist

          NOTES_FILE="$RUNNER_TEMP/release-notes.md"
          python3 scripts/release_notes_from_changelog.py --tag "$TAG" > "$NOTES_FILE"
          echo "Release notes preview:"
          sed -n '1,120p' "$NOTES_FILE"

          if gh release view "$TAG" --repo "$GH_REPO" >/dev/null 2>&1; then
            gh release edit "$TAG" --notes-file "$NOTES_FILE" --repo "$GH_REPO"
            gh release upload "$TAG" dist/* --clobber --repo "$GH_REPO"
            exit 0
          fi

          if [[ "$PRERELEASE" == "true" ]]; then
            gh release create "$TAG" dist/* --title "$TAG" --notes-file "$NOTES_FILE" --prerelease --repo "$GH_REPO"
          else
            gh release create "$TAG" dist/* --title "$TAG" --notes-file "$NOTES_FILE" --repo "$GH_REPO"
          fi

  update-homebrew-tap:
    needs: publish-release
    uses: ./.github/workflows/update-homebrew-tap.yml
    secrets: inherit
