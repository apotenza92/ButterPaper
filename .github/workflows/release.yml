name: Release

on:
  push:
    tags:
      - "v*"

permissions:
  contents: write

env:
  CARGO_TERM_COLOR: always

jobs:
  prepare:
    runs-on: ubuntu-latest
    outputs:
      tag: ${{ steps.meta.outputs.tag }}
      version_core: ${{ steps.meta.outputs.version_core }}
      prerelease: ${{ steps.meta.outputs.prerelease }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Parse tag metadata
        id: meta
        shell: bash
        run: |
          set -euo pipefail

          TAG="${GITHUB_REF_NAME}"
          CORE=""
          PRERELEASE="false"

          if [[ "$TAG" =~ ^v([0-9]+\.[0-9]+\.[0-9]+)$ ]]; then
            CORE="${BASH_REMATCH[1]}"
            PRERELEASE="false"
          elif [[ "$TAG" =~ ^v([0-9]+\.[0-9]+\.[0-9]+)-beta\.([0-9]+)$ ]]; then
            CORE="${BASH_REMATCH[1]}"
            PRERELEASE="true"
          else
            echo "::error::Tag must match vX.Y.Z or vX.Y.Z-beta.N"
            exit 1
          fi

          WORKSPACE_VERSION="$(awk '
            /^\[workspace\.package\]/ { in_section=1; next }
            /^\[/ && in_section { in_section=0 }
            in_section && /^version = / {
              gsub(/"/, "", $3)
              print $3
              exit
            }
          ' Cargo.toml)"

          if [[ "$WORKSPACE_VERSION" != "$CORE" ]]; then
            echo "::error::Tag core version ($CORE) must match workspace version ($WORKSPACE_VERSION)."
            exit 1
          fi

          echo "tag=$TAG" >> "$GITHUB_OUTPUT"
          echo "version_core=$CORE" >> "$GITHUB_OUTPUT"
          echo "prerelease=$PRERELEASE" >> "$GITHUB_OUTPUT"

  build-macos:
    needs: prepare
    strategy:
      fail-fast: false
      matrix:
        include:
          - runner: macos-14
            arch: arm64
            target: aarch64-apple-darwin
          - runner: macos-14
            arch: x64
            target: x86_64-apple-darwin
    runs-on: ${{ matrix.runner }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      - name: Rust cache
        uses: Swatinem/rust-cache@v2

      - name: Import Apple signing certificate
        shell: bash
        env:
          APPLE_SIGNING_CERTIFICATE_P12_BASE64: ${{ secrets.APPLE_SIGNING_CERTIFICATE_P12_BASE64 }}
          APPLE_SIGNING_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_SIGNING_CERTIFICATE_PASSWORD }}
        run: |
          set -euo pipefail

          test -n "$APPLE_SIGNING_CERTIFICATE_P12_BASE64"
          test -n "$APPLE_SIGNING_CERTIFICATE_PASSWORD"

          KEYCHAIN_PASSWORD="$(openssl rand -hex 16)"
          KEYCHAIN_PATH="$RUNNER_TEMP/butterpaper-signing.keychain-db"
          CERT_PATH="$RUNNER_TEMP/butterpaper-signing.p12"

          CERT_PATH="$CERT_PATH" python3 - <<'PY'
          import base64
          import os
          from pathlib import Path

          data = os.environ["APPLE_SIGNING_CERTIFICATE_P12_BASE64"]
          Path(os.environ["CERT_PATH"]).write_bytes(base64.b64decode(data))
          PY

          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security list-keychains -d user -s "$KEYCHAIN_PATH"
          security import "$CERT_PATH" \
            -k "$KEYCHAIN_PATH" \
            -P "$APPLE_SIGNING_CERTIFICATE_PASSWORD" \
            -T /usr/bin/codesign \
            -T /usr/bin/security
          security set-key-partition-list -S apple-tool:,apple: -s -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

      - name: Install cargo-bundle
        shell: bash
        run: cargo install cargo-bundle --locked

      - name: Build and package macOS bundles
        shell: bash
        env:
          VERSION_CORE: ${{ needs.prepare.outputs.version_core }}
          PRERELEASE: ${{ needs.prepare.outputs.prerelease }}
          APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_SIGNING_IDENTITY }}
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
          APPLE_APP_SPECIFIC_PASSWORD: ${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }}
          APPLE_NOTARYTOOL_KEY_ID: ${{ secrets.APPLE_NOTARYTOOL_KEY_ID }}
          APPLE_NOTARYTOOL_ISSUER_ID: ${{ secrets.APPLE_NOTARYTOOL_ISSUER_ID }}
          APPLE_NOTARYTOOL_KEY_P8_BASE64: ${{ secrets.APPLE_NOTARYTOOL_KEY_P8_BASE64 }}
        run: |
          set -euo pipefail

          test -n "$APPLE_SIGNING_IDENTITY"

          cargo bundle --release --format osx --package butterpaper --target "${{ matrix.target }}"

          APP_PATH="target/${{ matrix.target }}/release/bundle/osx/ButterPaper.app"
          if [[ ! -d "$APP_PATH" ]]; then
            echo "::error::Expected app bundle not found at $APP_PATH"
            exit 1
          fi

          bash scripts/apply_macos_tahoe_bundle_icons.sh "$APP_PATH"

          codesign --force --deep --options runtime --timestamp --sign "$APPLE_SIGNING_IDENTITY" "$APP_PATH"
          codesign --verify --deep --strict --verbose=2 "$APP_PATH"

          NOTARY_MODE="none"
          NOTARY_KEY_PATH=""
          if [[ -n "${APPLE_ID:-}" && -n "${APPLE_TEAM_ID:-}" && -n "${APPLE_APP_SPECIFIC_PASSWORD:-}" ]]; then
            NOTARY_MODE="apple_id"
          elif [[ -n "${APPLE_NOTARYTOOL_KEY_ID:-}" && -n "${APPLE_NOTARYTOOL_ISSUER_ID:-}" && -n "${APPLE_NOTARYTOOL_KEY_P8_BASE64:-}" ]]; then
            NOTARY_MODE="api_key"
            NOTARY_KEY_PATH="$RUNNER_TEMP/apple-notary-api-key.p8"
            NOTARY_KEY_PATH="$NOTARY_KEY_PATH" python3 -c 'import base64,os; from pathlib import Path; Path(os.environ["NOTARY_KEY_PATH"]).write_bytes(base64.b64decode(os.environ["APPLE_NOTARYTOOL_KEY_P8_BASE64"]))'
          fi

          maybe_notarize_and_staple() {
            local app_path="$1"
            if [[ "$NOTARY_MODE" == "none" ]]; then
              return 0
            fi

            local tmp_zip="$RUNNER_TEMP/notary-upload.zip"
            rm -f "$tmp_zip"
            ditto -c -k --sequesterRsrc --keepParent "$app_path" "$tmp_zip"

            if [[ "$NOTARY_MODE" == "api_key" ]]; then
              xcrun notarytool submit "$tmp_zip" \
                --key "$NOTARY_KEY_PATH" \
                --key-id "$APPLE_NOTARYTOOL_KEY_ID" \
                --issuer "$APPLE_NOTARYTOOL_ISSUER_ID" \
                --wait
            else
              xcrun notarytool submit "$tmp_zip" \
                --apple-id "$APPLE_ID" \
                --team-id "$APPLE_TEAM_ID" \
                --password "$APPLE_APP_SPECIFIC_PASSWORD" \
                --wait
            fi

            xcrun stapler staple -v "$app_path"
          }

          mkdir -p dist

          package_stable() {
            local output="dist/ButterPaper-v${VERSION_CORE}-macos-${{ matrix.arch }}.zip"
            maybe_notarize_and_staple "$APP_PATH"
            ditto -c -k --sequesterRsrc --keepParent "$APP_PATH" "$output"
          }

          package_beta() {
            local tmp_dir
            tmp_dir="$(mktemp -d)"
            cp -R "$APP_PATH" "$tmp_dir/ButterPaper Beta.app"
            local plist="$tmp_dir/ButterPaper Beta.app/Contents/Info.plist"
            /usr/libexec/PlistBuddy -c "Set :CFBundleDisplayName ButterPaper Beta" "$plist" || true
            /usr/libexec/PlistBuddy -c "Set :CFBundleName ButterPaper Beta" "$plist" || true
            /usr/libexec/PlistBuddy -c "Set :CFBundleIdentifier com.apotenza92.butterpaper.beta" "$plist" || true
            codesign --force --deep --options runtime --timestamp --sign "$APPLE_SIGNING_IDENTITY" "$tmp_dir/ButterPaper Beta.app"
            codesign --verify --deep --strict --verbose=2 "$tmp_dir/ButterPaper Beta.app"
            maybe_notarize_and_staple "$tmp_dir/ButterPaper Beta.app"
            local output="dist/ButterPaper-Beta-v${VERSION_CORE}-macos-${{ matrix.arch }}.zip"
            ditto -c -k --sequesterRsrc --keepParent "$tmp_dir/ButterPaper Beta.app" "$output"
            rm -rf "$tmp_dir"
          }

          if [[ "$PRERELEASE" == "true" ]]; then
            package_beta
          else
            package_stable
            package_beta
          fi

      - name: Upload macOS artifacts
        uses: actions/upload-artifact@v4
        with:
          name: release-macos-${{ matrix.arch }}
          path: dist/*
          if-no-files-found: error

  build-windows:
    needs: prepare
    strategy:
      fail-fast: false
      matrix:
        include:
          - arch: x64
            target: x86_64-pc-windows-msvc
          - arch: arm64
            target: aarch64-pc-windows-msvc
    runs-on: windows-2022
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      - name: Rust cache
        uses: Swatinem/rust-cache@v2

      - name: Install NSIS
        shell: pwsh
        run: |
          if (-not (Get-Command makensis -ErrorAction SilentlyContinue)) {
            choco install nsis -y --no-progress
          }

      - name: Build and package Windows installers
        shell: pwsh
        env:
          VERSION_CORE: ${{ needs.prepare.outputs.version_core }}
          PRERELEASE: ${{ needs.prepare.outputs.prerelease }}
        run: |
          $ErrorActionPreference = "Stop"

          cargo build --release --package butterpaper --target "${{ matrix.target }}"

          $binary = Join-Path $PWD "target\${{ matrix.target }}\release\butterpaper.exe"
          if (!(Test-Path $binary)) {
            throw "Expected binary not found: $binary"
          }

          New-Item -ItemType Directory -Force -Path dist | Out-Null
          $nsisScript = Join-Path $PWD "scripts\release\windows_installer.nsi"

          function Build-Installer([string]$prefix, [string]$appName, [string]$installSubdir) {
            $output = Join-Path $PWD ("dist\{0}-v{1}-windows-${{ matrix.arch }}-setup.exe" -f $prefix, $env:VERSION_CORE)
            $args = @(
              "/DOUTPUT_FILE=$output",
              "/DSOURCE_EXE=$binary",
              "/DAPP_NAME=$appName",
              "/DINSTALL_SUBDIR=$installSubdir",
              $nsisScript
            )
            & makensis @args
          }

          if ($env:PRERELEASE -eq "true") {
            Build-Installer "ButterPaper-Beta" "ButterPaper Beta" "ButterPaper-Beta"
          } else {
            Build-Installer "ButterPaper" "ButterPaper" "ButterPaper"
            Build-Installer "ButterPaper-Beta" "ButterPaper Beta" "ButterPaper-Beta"
          }

      - name: Upload Windows artifacts
        uses: actions/upload-artifact@v4
        with:
          name: release-windows-${{ matrix.arch }}
          path: dist/*
          if-no-files-found: error

  build-linux:
    needs: prepare
    strategy:
      fail-fast: false
      matrix:
        include:
          - runner: ubuntu-24.04
            arch: x64
            target: x86_64-unknown-linux-gnu
            deb_arch: amd64
            rpm_arch: x86_64
            appimage_arch: x86_64
          - runner: ubuntu-24.04-arm
            arch: arm64
            target: aarch64-unknown-linux-gnu
            deb_arch: arm64
            rpm_arch: aarch64
            appimage_arch: aarch64
    runs-on: ${{ matrix.runner }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      - name: Rust cache
        uses: Swatinem/rust-cache@v2

      - name: Install packaging dependencies
        shell: bash
        run: |
          set -euo pipefail
          sudo apt-get update
          sudo apt-get install -y \
            build-essential \
            pkg-config \
            rpm \
            ruby \
            ruby-dev \
            libpipewire-0.3-dev \
            libspa-0.2-dev \
            libegl1-mesa-dev \
            libgl1-mesa-dev \
            libgbm-dev \
            libxkbcommon-dev \
            libxkbcommon-x11-dev \
            libwayland-dev \
            libx11-dev \
            libxi-dev \
            libxcursor-dev \
            libxrandr-dev \
            libxinerama-dev \
            libdbus-1-dev \
            libudev-dev \
            libasound2-dev
          sudo gem install --no-document fpm

      - name: Build and package Linux artifacts
        shell: bash
        env:
          VERSION_CORE: ${{ needs.prepare.outputs.version_core }}
          PRERELEASE: ${{ needs.prepare.outputs.prerelease }}
          APPIMAGE_ARCH: ${{ matrix.appimage_arch }}
          TARGET_TRIPLE: ${{ matrix.target }}
          DEB_ARCH: ${{ matrix.deb_arch }}
          RPM_ARCH: ${{ matrix.rpm_arch }}
          OUT_ARCH: ${{ matrix.arch }}
        run: |
          set -euo pipefail

          cargo build --release --package butterpaper --target "$TARGET_TRIPLE"

          BIN_PATH="target/$TARGET_TRIPLE/release/butterpaper"
          if [[ ! -x "$BIN_PATH" ]]; then
            echo "::error::Expected binary not found at $BIN_PATH"
            exit 1
          fi

          mkdir -p dist

          APPDIR="$(mktemp -d)"
          export APPDIR
          mkdir -p "$APPDIR/usr/bin" "$APPDIR/usr/share/applications" "$APPDIR/usr/share/icons/hicolor/256x256/apps"
          cp "$BIN_PATH" "$APPDIR/usr/bin/ButterPaper"
          chmod +x "$APPDIR/usr/bin/ButterPaper"
          # appimagetool falls back to scanning *.so.* for architecture; provide one deterministically.
          mkdir -p "$APPDIR/usr/lib"
          ln -sf ../bin/ButterPaper "$APPDIR/usr/lib/libbutterpaper.so.0"
          cp "crates/gpui-app/assets/app-icons/butterpaper-icon-256.png" "$APPDIR/usr/share/icons/hicolor/256x256/apps/butterpaper.png"

          python3 - <<'PY'
          import os
          from pathlib import Path

          appdir = os.environ["APPDIR"]

          Path(f"{appdir}/butterpaper.desktop").write_text(
              "[Desktop Entry]\n"
              "Name=ButterPaper\n"
              "Comment=Rust-native desktop PDF app\n"
              "Exec=ButterPaper\n"
              "Icon=butterpaper\n"
              "Type=Application\n"
              "Categories=Office;Viewer;\n"
              "Terminal=false\n",
              encoding="utf-8",
          )

          Path(f"{appdir}/AppRun").write_text(
              "#!/bin/sh\n"
              "HERE=\\\"$(dirname \\\"$(readlink -f \\\"$0\\\")\\\")\\\"\n"
              "exec \\\"$HERE/usr/bin/ButterPaper\\\" \\\"$@\\\"\\n",
              encoding="utf-8",
          )
          PY
          cp "$APPDIR/butterpaper.desktop" "$APPDIR/usr/share/applications/butterpaper.desktop"
          chmod +x "$APPDIR/AppRun"
          ln -s usr/share/icons/hicolor/256x256/apps/butterpaper.png "$APPDIR/butterpaper.png"

          curl -fsSL -o appimagetool \
            "https://github.com/AppImage/appimagetool/releases/download/1.9.1/appimagetool-${APPIMAGE_ARCH}.AppImage"
          chmod +x appimagetool
          APPIMAGE_TMP="ButterPaper-${OUT_ARCH}.AppImage"
          export ARCH="$APPIMAGE_ARCH"
          export APPIMAGE_EXTRACT_AND_RUN=1
          ./appimagetool --no-appstream "$APPDIR" "$APPIMAGE_TMP"

          PKGROOT="$(mktemp -d)"
          mkdir -p "$PKGROOT/usr/bin" "$PKGROOT/usr/share/applications" "$PKGROOT/usr/share/icons/hicolor/256x256/apps"
          cp "$BIN_PATH" "$PKGROOT/usr/bin/butterpaper"
          chmod +x "$PKGROOT/usr/bin/butterpaper"
          cp "$APPDIR/butterpaper.desktop" "$PKGROOT/usr/share/applications/butterpaper.desktop"
          cp "crates/gpui-app/assets/app-icons/butterpaper-icon-256.png" "$PKGROOT/usr/share/icons/hicolor/256x256/apps/butterpaper.png"

          fpm -s dir -t deb \
            -n butterpaper \
            -v "$VERSION_CORE" \
            -a "$DEB_ARCH" \
            --maintainer "apotenza92" \
            --description "Rust-native desktop PDF app" \
            --url "https://github.com/apotenza92/ButterPaper" \
            -C "$PKGROOT" \
            .

          fpm -s dir -t rpm \
            -n butterpaper \
            -v "$VERSION_CORE" \
            -a "$RPM_ARCH" \
            --maintainer "apotenza92" \
            --description "Rust-native desktop PDF app" \
            --url "https://github.com/apotenza92/ButterPaper" \
            -C "$PKGROOT" \
            .

          DEB_FILE="$(ls -1 butterpaper_"${VERSION_CORE}"_*.deb | head -n1)"
          RPM_FILE="$(ls -1 butterpaper-"${VERSION_CORE}"-*.rpm | head -n1)"

          publish_prefix() {
            local prefix="$1"
            cp "$APPIMAGE_TMP" "dist/${prefix}-v${VERSION_CORE}-linux-${OUT_ARCH}.AppImage"
            cp "$DEB_FILE" "dist/${prefix}-v${VERSION_CORE}-linux-${OUT_ARCH}.deb"
            cp "$RPM_FILE" "dist/${prefix}-v${VERSION_CORE}-linux-${OUT_ARCH}.rpm"
          }

          if [[ "$PRERELEASE" == "true" ]]; then
            publish_prefix "ButterPaper-Beta"
          else
            publish_prefix "ButterPaper"
            publish_prefix "ButterPaper-Beta"
          fi

      - name: Upload Linux artifacts
        uses: actions/upload-artifact@v4
        with:
          name: release-linux-${{ matrix.arch }}
          path: dist/*
          if-no-files-found: error

  publish-release:
    needs:
      - prepare
      - build-macos
      - build-windows
      - build-linux
    runs-on: ubuntu-latest
    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: release-*
          merge-multiple: true
          path: dist

      - name: Publish GitHub release
        env:
          GH_TOKEN: ${{ github.token }}
          GH_REPO: ${{ github.repository }}
          TAG: ${{ needs.prepare.outputs.tag }}
          PRERELEASE: ${{ needs.prepare.outputs.prerelease }}
        shell: bash
        run: |
          set -euo pipefail

          ls -lah dist

          if gh release view "$TAG" --repo "$GH_REPO" >/dev/null 2>&1; then
            gh release upload "$TAG" dist/* --clobber --repo "$GH_REPO"
            exit 0
          fi

          if [[ "$PRERELEASE" == "true" ]]; then
            gh release create "$TAG" dist/* --title "$TAG" --generate-notes --prerelease --repo "$GH_REPO"
          else
            gh release create "$TAG" dist/* --title "$TAG" --generate-notes --repo "$GH_REPO"
          fi

  update-homebrew-tap:
    needs: publish-release
    runs-on: ubuntu-latest
    # Skip automatically if tap credentials aren't configured yet.
    if: ${{ secrets.HOMEBREW_TAP_PAT != '' || secrets.HOMEBREW_TAP_SSH_KEY != '' }}
    steps:
      - name: Checkout ButterPaper
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Clone homebrew tap
        env:
          HOMEBREW_TAP_PAT: ${{ secrets.HOMEBREW_TAP_PAT }}
          HOMEBREW_TAP_SSH_KEY: ${{ secrets.HOMEBREW_TAP_SSH_KEY }}
        shell: bash
        run: |
          set -euo pipefail

          if [[ -n "${HOMEBREW_TAP_PAT:-}" ]]; then
            git clone "https://x-access-token:${HOMEBREW_TAP_PAT}@github.com/apotenza92/homebrew-tap.git" /tmp/homebrew-tap
            exit 0
          fi

          mkdir -p "$HOME/.ssh"
          chmod 700 "$HOME/.ssh"
          printf '%s\n' "$HOMEBREW_TAP_SSH_KEY" > "$HOME/.ssh/id_ed25519"
          chmod 600 "$HOME/.ssh/id_ed25519"
          ssh-keyscan github.com >> "$HOME/.ssh/known_hosts"
          git clone "git@github.com:apotenza92/homebrew-tap.git" /tmp/homebrew-tap

      - name: Update casks from release data
        run: |
          python3 scripts/release/update_homebrew_tap_casks.py --tap-path /tmp/homebrew-tap

      - name: Commit and push changes
        run: |
          cd /tmp/homebrew-tap
          if git diff --quiet -- Casks/butterpaper.rb Casks/butterpaper@beta.rb; then
            echo "No cask changes to push."
            exit 0
          fi

          git config user.name "butterpaper-release-bot"
          git config user.email "actions@users.noreply.github.com"

          git add Casks/butterpaper.rb Casks/butterpaper@beta.rb
          git commit -m "Update ButterPaper casks from release metadata"
          git push origin main
